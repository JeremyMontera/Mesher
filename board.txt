mesh 1 - create point class                         x
    (1) implement point interface                   x
    (2) write point class against this interface    x
    (3) write unit tests                            x
    (4) docs...                                     x

mesh 2 - create ring class and properties           x
    (1) implement node class                        x
    (2) implement ring interface                    x
    (3) write ring class properties                 x
    (4) write unit tests                            x
    (5) docs...                                     x

mesh 3 - write add_point and find point methods     x
    (1) write methods according to interface        x
    (2) write unit tests                            x
    (3) update docs                                 x

mesh 4 - write insert_point method                  x
    (1) decide how insert_point should be called    x
        - can I call after being closed?
    (2) implement insert_point based on this        x
    (3) write unit tests                            x
    (4) update docs                                 x

mesh 5 - write close method                         x
    (1) actually write the god damn method          x
    (2) allow users to print nodes to screen        x
    (2) write unit tests                            x
    (3) update/add docs...                          x

mesh 6 - reverse ring                               x
    (1) decide when reverse should be called        x
    (2) write implementation                        x
    (3) write unit tests                            x
    (4) docs...                                     x

mesh 7 - remove collinear points
    (1) update Point class to test collinears
    (2) write implementation to delete points
    (3) write implementation to delete collinears
    (4) write unit tests
    (5) docs...